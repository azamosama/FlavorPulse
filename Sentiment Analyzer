import type { Review } from "./scraper/types"
import { generateText } from "ai"
import { openai } from "@ai-sdk/openai"

export interface SentimentResult {
  sentiment: "positive" | "neutral" | "negative"
  score: number // 0-100
  categories: {
    [category: string]: number // 0-100
  }
  menuItems: {
    [item: string]: {
      mentioned: boolean
      sentiment: "positive" | "neutral" | "negative"
      score: number // 0-100
    }
  }
}

export async function analyzeSentiment(review: Review): Promise<SentimentResult> {
  try {
    // Define the menu items and categories we want to analyze
    const menuItems = [
      "Chick-In Maple",
      "Spicy Chick",
      "Chick-In Fries",
      "Queso Fries",
      "Chicken & Waffles",
      "Wings",
      "Chicken Tenders",
      "Mac & Cheese",
    ]

    const categories = ["Food Quality", "Customer Service", "Cleanliness", "Value for Money", "Wait Times", "Ambiance"]

    // Use AI to analyze the sentiment
    const { text: analysisResult } = await generateText({
      model: openai("gpt-4o"),
      prompt: `Analyze the sentiment of this restaurant review. Extract overall sentiment, 
      category-specific sentiment, and mentions of specific menu items.
      
      Review: "${review.text}"
      
      Rating: ${review.rating} out of 5
      
      Categories to analyze: ${categories.join(", ")}
      Menu items to detect: ${menuItems.join(", ")}
      
      Return a JSON object with this structure:
      {
        "sentiment": "positive"|"neutral"|"negative",
        "score": number from 0-100,
        "categories": {
          "Food Quality": number from 0-100,
          "Customer Service": number from 0-100,
          ... (other categories)
        },
        "menuItems": {
          "Chick-In Maple": {
            "mentioned": boolean,
            "sentiment": "positive"|"neutral"|"negative",
            "score": number from 0-100
          },
          ... (other menu items)
        }
      }
      
      Only include menu items that are actually mentioned in the review.
      If a category isn't mentioned, set its score to null.
      Base your analysis on both the text content and the numerical rating.`,
    })

    // Parse the AI-generated JSON
    const analysis = JSON.parse(analysisResult)
    return analysis as SentimentResult
  } catch (error) {
    console.error("Error analyzing sentiment:", error)
    // Return a default neutral sentiment if analysis fails
    return {
      sentiment: "neutral",
      score: 50,
      categories: {},
      menuItems: {},
    }
  }
}

export async function batchAnalyzeSentiment(reviews: Review[]): Promise<{
  reviews: (Review & { sentiment: SentimentResult })[]
  summary: any
}> {
  // Process reviews in batches to avoid rate limits
  const batchSize = 10
  const analyzedReviews = []

  for (let i = 0; i < reviews.length; i += batchSize) {
    const batch = reviews.slice(i, i + batchSize)
    const batchPromises = batch.map(async (review) => {
      const sentiment = await analyzeSentiment(review)
      return { ...review, sentiment }
    })

    const batchResults = await Promise.all(batchPromises)
    analyzedReviews.push(...batchResults)

    // Add a small delay between batches to avoid rate limits
    if (i + batchSize < reviews.length) {
      await new Promise((resolve) => setTimeout(resolve, 1000))
    }
  }

  // Generate a summary of all analyzed reviews
  const summary = generateSummary(analyzedReviews)

  return {
    reviews: analyzedReviews,
    summary,
  }
}

function generateSummary(analyzedReviews: (Review & { sentiment: SentimentResult })[]): any {
  // Calculate overall sentiment
  const totalScore = analyzedReviews.reduce((sum, review) => sum + review.sentiment.score, 0)
  const averageScore = totalScore / analyzedReviews.length

  // Count sentiment distribution
  const sentimentCounts = {
    positive: analyzedReviews.filter((r) => r.sentiment.sentiment === "positive").length,
    neutral: analyzedReviews.filter((r) => r.sentiment.sentiment === "neutral").length,
    negative: analyzedReviews.filter((r) => r.sentiment.sentiment === "negative").length,
  }

  // Calculate percentages
  const total = analyzedReviews.length
  const sentimentPercentages = {
    positive: Math.round((sentimentCounts.positive / total) * 100),
    neutral: Math.round((sentimentCounts.neutral / total) * 100),
    negative: Math.round((sentimentCounts.negative / total) * 100),
  }

  // Analyze by platform
  const platforms = {}
  analyzedReviews.forEach((review) => {
    if (!platforms[review.platform]) {
      platforms[review.platform] = {
        count: 0,
        positive: 0,
        neutral: 0,
        negative: 0,
        avgRating: 0,
        totalRating: 0,
      }
    }

    platforms[review.platform].count++
    platforms[review.platform].totalRating += review.rating

    if (review.sentiment.sentiment === "positive") {
      platforms[review.platform].positive++
    } else if (review.sentiment.sentiment === "neutral") {
      platforms[review.platform].neutral++
    } else {
      platforms[review.platform].negative++
    }
  })

  // Calculate averages for platforms
  Object.keys(platforms).forEach((platform) => {
    const p = platforms[platform]
    p.avgRating = Math.round((p.totalRating / p.count) * 10) / 10
    p.positive = Math.round((p.positive / p.count) * 100)
    p.neutral = Math.round((p.neutral / p.count) * 100)
    p.negative = Math.round((p.negative / p.count) * 100)
  })

  // Analyze by location
  const locations = {}
  analyzedReviews.forEach((review) => {
    if (!locations[review.location]) {
      locations[review.location] = {
        count: 0,
        positive: 0,
        neutral: 0,
        negative: 0,
        avgRating: 0,
        totalRating: 0,
      }
    }

    locations[review.location].count++
    locations[review.location].totalRating += review.rating

    if (review.sentiment.sentiment === "positive") {
      locations[review.location].positive++
    } else if (review.sentiment.sentiment === "neutral") {
      locations[review.location].neutral++
    } else {
      locations[review.location].negative++
    }
  })

  // Calculate averages for locations
  Object.keys(locations).forEach((location) => {
    const l = locations[location]
    l.avgRating = Math.round((l.totalRating / l.count) * 10) / 10
    l.positive = Math.round((l.positive / l.count) * 100)
    l.neutral = Math.round((l.neutral / l.count) * 100)
    l.negative = Math.round((l.negative / l.count) * 100)
  })

  // Analyze menu items
  const menuItems = {}
  analyzedReviews.forEach((review) => {
    Object.entries(review.sentiment.menuItems).forEach(([item, data]) => {
      if (!menuItems[item]) {
        menuItems[item] = {
          mentions: 0,
          positive: 0,
          neutral: 0,
          negative: 0,
          totalScore: 0,
        }
      }

      menuItems[item].mentions++
      menuItems[item].totalScore += data.score

      if (data.sentiment === "positive") {
        menuItems[item].positive++
      } else if (data.sentiment === "neutral") {
        menuItems[item].neutral++
      } else {
        menuItems[item].negative++
      }
    })
  })

  // Calculate averages for menu items
  Object.keys(menuItems).forEach((item) => {
    const m = menuItems[item]
    m.score = Math.round(m.totalScore / m.mentions)
    m.positive = Math.round((m.positive / m.mentions) * 100)
    m.neutral = Math.round((m.neutral / m.mentions) * 100)
    m.negative = Math.round((m.negative / m.mentions) * 100)
  })

  // Analyze categories
  const categories = {}
  analyzedReviews.forEach((review) => {
    Object.entries(review.sentiment.categories).forEach(([category, score]) => {
      if (score === null) return

      if (!categories[category]) {
        categories[category] = {
          mentions: 0,
          totalScore: 0,
        }
      }

      categories[category].mentions++
      categories[category].totalScore += score
    })
  })

  // Calculate averages for categories
  Object.keys(categories).forEach((category) => {
    const c = categories[category]
    c.score = Math.round(c.totalScore / c.mentions)
  })

  return {
    overall: {
      positive: sentimentPercentages.positive,
      neutral: sentimentPercentages.neutral,
      negative: sentimentPercentages.negative,
      averageScore,
    },
    reviews: analyzedReviews.length,
    platforms,
    locations,
    menuItems,
    categories,
  }
}
